import{j as a,b as s,c as i,aG as t}from"./chunks/framework.73Ljzr8Y.js";const _=JSON.parse('{"title":"如何避免多线程场景下notifyAll的虚假唤醒","description":"","frontmatter":{"title":"如何避免多线程场景下notifyAll的虚假唤醒","date":"2023-03-12T17:03:56.000Z","permalink":"/pages/40a0fd/","categories":["技术","错题本"],"tags":["java"]},"headers":[],"relativePath":"tech/wrong/02.如何避免多线程场景下notifyAll的虚假唤醒.md","filePath":"tech/wrong/02.如何避免多线程场景下notifyAll的虚假唤醒.md","lastUpdated":1704104554000}'),n={name:"tech/wrong/02.如何避免多线程场景下notifyAll的虚假唤醒.md"},e=t(`<h2 id="前情提要" tabindex="-1">前情提要 <a class="header-anchor" href="#前情提要" aria-label="Permalink to &quot;前情提要&quot;">​</a></h2><p>当我们使用java内置锁实现一个简单的生产者-消费者模型的时候，可以使用基类Object提供的wait、notify和notifyAll同步方法。<br> 在调用对象的同步方法时，必须将其放在synchronized关键字修饰的同步代码块、同步方法中。如下所示：<br></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (竞态条件) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但当我们使用obj.notifyAll()方法唤醒正在wait中的线程的时候，却可能会出现虚假唤醒。<br></p><h2 id="什么是虚假唤醒" tabindex="-1">什么是虚假唤醒 <a class="header-anchor" href="#什么是虚假唤醒" aria-label="Permalink to &quot;什么是虚假唤醒&quot;">​</a></h2><p>一个生产者生产完毕之后，调用notifyAll()将多个消费者线程唤醒，多个消费者同时被唤醒并执行消费逻辑，导致多次消费。</p><h2 id="为什么会产生虚假唤醒" tabindex="-1">为什么会产生虚假唤醒 <a class="header-anchor" href="#为什么会产生虚假唤醒" aria-label="Permalink to &quot;为什么会产生虚假唤醒&quot;">​</a></h2><p>当一个线程从wait()状态被唤醒后，会从wait()代码行的下一行继续执行，并且会重新等待尝试获取锁。<br> 当第一个消费者线程获取锁并执行消费后，第二个消费者线程也会获得锁并且执行消费，但此时可能第二个消费者并不满足静态条件，从而出现虚假唤醒。</p><h2 id="如何解决虚假唤醒" tabindex="-1">如何解决虚假唤醒 <a class="header-anchor" href="#如何解决虚假唤醒" aria-label="Permalink to &quot;如何解决虚假唤醒&quot;">​</a></h2><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (obj) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (竞态条件) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 此处需要将if改为while</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    obj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wait</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>由于if判断只会判断一次，因此无法在wait()被唤醒之后再次进行判断。<br> 因此，需要将if改为while，在本次循环结束之后再进行一次竞态条件判断，如果满足条件，则继续进行wait()<br></p>`,11),l=[e];function h(p,r,o,k,d,c){return s(),i("div",null,l)}const g=a(n,[["render",h]]);export{_ as __pageData,g as default};
