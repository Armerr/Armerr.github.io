import{_ as s,c as i,o as a,aH as n}from"./chunks/framework.BJ3AeCMO.js";const c=JSON.parse('{"title":"Spring 循环引用的机制与 @Async 注解导致项目无法启动的问题","description":"","frontmatter":{"title":"Spring 循环引用的机制与 @Async 注解导致项目无法启动的问题","date":"2024-06-30T20:56:02.000Z","categories":["技术","错题本"],"tags":[null]},"headers":[],"relativePath":"tech/wrong/Spring 循环引用的机制与 @Async 注解导致项目无法启动的问题.md","filePath":"tech/wrong/Spring 循环引用的机制与 @Async 注解导致项目无法启动的问题.md","lastUpdated":1719751416000}'),l={name:"tech/wrong/Spring 循环引用的机制与 @Async 注解导致项目无法启动的问题.md"},h=n(`<h2 id="_1、背景" tabindex="-1">1、背景 <a class="header-anchor" href="#_1、背景" aria-label="Permalink to &quot;1、背景&quot;">​</a></h2><p>在某次常规发版中，对某个方法进行了一下改进。主要目的是将一些逻辑处理的消息队列任务从事务处理中独立出来，以确保这个任务在事务提交后执行。因此使用了Spring中的事件发布器，在事务完成后再发送消息。为实现这一功能添加了以下代码[先忽略为什么异步后还要异步，因为代码是复制来的:(]</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TransactionalEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">phase</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TransactionPhase.AFTER_COMMIT)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Async</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TestEvent event) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (StringUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Order</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orderRepository.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">findByIdAndStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(o </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rabbitTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convertAndSend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(QueueConstants.EXCHANGE, QueueConstants.QUEUE_KEY, o.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然而，发版后项目在启动时出现了错误。经过排查发现问题出在加入上述代码的类与另一个类之间存在循环注入。在添加这段代码之前，项目能够正常启动。尽管尝试通过指定 <code>@Async(SimpleEventMultiConfig.THREADPOOLTASKEXECUTOR)</code> 来解决问题，启动时仍然报错。最终发现去掉 <code>@Async</code> 注解后，项目能够正常启动。</p><h2 id="_2-spring-中的循环引用机制" tabindex="-1">2.Spring 中的循环引用机制 <a class="header-anchor" href="#_2-spring-中的循环引用机制" aria-label="Permalink to &quot;2.Spring 中的循环引用机制&quot;">​</a></h2><h4 id="_2-1-什么是循环引用" tabindex="-1">2.1 什么是循环引用 <a class="header-anchor" href="#_2-1-什么是循环引用" aria-label="Permalink to &quot;2.1 什么是循环引用&quot;">​</a></h4><p>循环引用是指两个或多个 Bean 互相引用对方，形成一个循环依赖链。例如，Bean A 依赖于 Bean B，而 Bean B 又依赖于 Bean A。</p><h4 id="_2-2-spring-如何处理循环引用" tabindex="-1">2.2 Spring 如何处理循环引用 <a class="header-anchor" href="#_2-2-spring-如何处理循环引用" aria-label="Permalink to &quot;2.2 Spring 如何处理循环引用&quot;">​</a></h4><p>Spring 通过三级缓存（三级单例模式）机制来解决循环引用的问题。这个机制可以确保在 Bean 之间存在循环引用的情况下，仍然能够正确地实例化和注入 Bean。</p><h4 id="_2-3-三级缓存机制" tabindex="-1">2.3 三级缓存机制 <a class="header-anchor" href="#_2-3-三级缓存机制" aria-label="Permalink to &quot;2.3 三级缓存机制&quot;">​</a></h4><p>Spring 的三级缓存机制包括以下三个缓存:</p><ol><li><strong>一级缓存</strong>（<code>singletonObjects</code>）： <ul><li>这是一个用于存储完全初始化完成的单例 Bean 的缓存。当 Bean 被完全初始化并准备好使用时，它会被放入一级缓存中。</li></ul></li><li><strong>二级缓存</strong>（<code>earlySingletonObjects</code>）： <ul><li>用于存储提前暴露的单例对象引用，这些对象是已经创建但尚未进行完全初始化的 Bean 实例。二级缓存用于减少对三级缓存的代理开销。</li></ul></li><li><strong>三级缓存</strong>（<code>singletonFactories</code>）： <ul><li>这是一个工厂缓存，存储的是创建单例 Bean 的工厂对象，用于生成对象的原始引用（未被代理）。当需要提前暴露对象引用时，Spring 会使用三级缓存来生成一个未完全初始化的 Bean 实例，并将其放入二级缓存中。</li></ul></li></ol><h4 id="_2-4-spring-处理循环引用的步骤" tabindex="-1">2.4 Spring 处理循环引用的步骤 <a class="header-anchor" href="#_2-4-spring-处理循环引用的步骤" aria-label="Permalink to &quot;2.4 Spring 处理循环引用的步骤&quot;">​</a></h4><p>举例如下(假设bean的初始化顺序为先A后B，spring默认提前暴露bean引用):</p><p>正常情况下的循环引用</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B b;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><pre><code>1. 首先创建A的实例，并将该实例的引用放入三级缓存中；
2. 填充A的属性，发现依赖B，从bean容器中没有找到B实例，于是创建B的实例；
3. 创建B实例，并将该实例的引用加入三级缓存；
4. B实例化完成后，填充A的属性，spring 会从三级缓存中获取A的引用，并将该引用填充到B的属性中, 此时B的属性A持有的是原始对象的引用（尚未完全初始化);
5. B完成其他属性的赋值，并执行初始化方法;
6. 继续完成A的属性赋值，A的属性B现在持有的是完全初始化的B的引用；
7. A 完全初始化后，将其放入一级缓存中，作为最终实例.
</code></pre><p>最终B 引用的A是原始对象，A引用的B是最终初始化完成的对象，整个过程正常完成，没有异常抛出。</p><p>使用@Async的循环引用</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Async</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A a;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><pre><code>1. 首先创建A的实例，并将该实例的引用放入三级缓存中；
2. 填充A的属性，发现依赖B，从bean容器中没有找到B实例，于是创建B的实例；
3. 创建B实例，并将该实例的引用加入三级缓存；
4. B实例化完成后，填充A的属性，spring 会从三级缓存中获取A的引用，并将该引用填充到B的属性中, 此时B的属性A持有的是原始对象的引用（尚未完全初始化),此时@Async还未被扫描;
5. B完成其他属性的赋值，并执行初始化方法,此时持有的A是原始类型引用（没有被代理）;
6. 完成A的属性的赋值（此时持有B的引用），继续执行初始化方法initializeBean(...)，解析@Aysnc注解生成一个代理对象,加入到容器里;
7. 问题出现了：B的属性A是个原始对象，而此处的实例A却是个代理对象;
8. 由于Spring是单例的，会在最后执行自检程序，由于 B 持有的 A 和最终放入容器的 A（代理对象）不一致，导致依赖关系的混乱，最终引发异常。代码如下：
</code></pre><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (earlySingletonExposure) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 依然从缓存中获取，注意这里第二个参数是false，也就是说只能从一级缓存、二级缓存中获取</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 因为此时还未放入一级缓存，所以肯定是没有的，只能从二级缓存中获取</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   Object earlySingletonReference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getSingleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beanName, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (earlySingletonReference </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 这里会进行一个比较，看二级缓存中的bean实例是否与初始化后的bean实例相等，此时发现并不相等</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (exposedObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bean) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         exposedObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> earlySingletonReference;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 接下来就会判断这个bean是否有其他bean进行依赖，如果有则说明注入到其他bean的依赖不是最终包装过后的bean</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.allowRawInjectionDespiteWrapping </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> hasDependentBean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beanName)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] dependentBeans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getDependentBeans</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beanName);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         Set&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; actualDependentBeans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedHashSet&lt;&gt;(dependentBeans.length);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (String dependentBean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dependentBeans) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeSingletonIfCreatedForTypeCheckOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dependentBean)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               actualDependentBeans.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dependentBean);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 所以这里就会抛异常（异常信息）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">actualDependentBeans.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BeanCurrentlyInCreationException</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beanName,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &quot;Bean with name &#39;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> beanName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&#39; has been injected into other beans [&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  StringUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">collectionToCommaDelimitedString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(actualDependentBeans) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &quot;wrapped. This means that said other beans do not use the final version of the &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &quot;bean. This is often the result of over-eager type matching - consider using &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                  &quot;&#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">         }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-5-lazy-注解避免循环依赖问题" tabindex="-1"><strong>2.5 <code>@Lazy</code> 注解避免循环依赖问题</strong> <a class="header-anchor" href="#_2-5-lazy-注解避免循环依赖问题" aria-label="Permalink to &quot;**2.5 \`@Lazy\` 注解避免循环依赖问题**&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Lazy</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B b;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">test2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当 Spring 容器启动时，Bean A 和 Bean B 不会立即被实例化，而是保持一种延迟加载的状态，由于 Bean B 是懒加载的，在 A 初始化过程中对 B 的访问会通过代理对象来实现，这个代理对象负责延迟初始化 B，由于 B 的初始化被推迟了，它不会在 A 初始化过程中暴露未完全初始化的引用，保证了 B 在被实际使用前是完整的；在 Bean B 被访问时，Spring 会创建一个一致的代理对象，这个代理对象会通过 AOP 机制确保所有对 B 的访问都指向这个代理对象，避免了循环依赖中的引用不一致问题。</p><h2 id="_3-结论" tabindex="-1"><strong>3. 结论</strong> <a class="header-anchor" href="#_3-结论" aria-label="Permalink to &quot;**3. 结论**&quot;">​</a></h2><p>循环依赖虽然可以通过技术手段解决，但通常会导致系统复杂性增加、性能下降和维护困难等问题。通过合理的设计和良好的编码习惯，可以避免循环依赖，提升系统的稳定性和可维护性。建议在实际开发中，尽量避免循环依赖，确保系统的模块化设计合理，类之间的依赖关系清晰且可控。</p>`,27),t=[h];function p(e,k,E,r,d,g){return a(),i("div",null,t)}const o=s(l,[["render",p]]);export{c as __pageData,o as default};
